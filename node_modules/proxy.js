exports.createServer = function(rewriter) {
    rewriter = rewriter || function(url) {
        return url;
    };
    return require('http').createServer(function(serverReq, serverRes) {
        var rule = rewriter(serverReq.url);
        if (!rule.url) {
            serverRes.end();
            return;
        }

        var delay = 0;
        rule.modifiers.some(function(modifier) {
            if (modifier.name == 'delay') {
                delay = +modifier.value;
                if (!isFinite(delay) || delay < 0) {
                    delay = 0;
                }
                return true;
            }
        });

        if (delay) {
            setTimeout(doRequest, delay * 1000);
        } else {
            doRequest();
        }

        function doRequest() {
            if (rule.url.indexOf('data:') == 0) {
                dataRequest(serverRes, rule.url.substr(5), rule.modifiers);
            } else if (rule.url.indexOf('file://') == 0) {
                fileRequest(serverRes, rule.url.substr(7).split('?')[0], rule.modifiers);
            } else if (rule.url.indexOf('http://') == 0) {
                httpRequest(serverReq, serverRes, rule.url, rule.modifiers);
            }
        }
    });
};


function httpRequest(serverReq, serverRes, url, modifiers) {
    var location = require('url').parse(url);
    var host = location.hostname || serverReq.headers['host'];
    var requestOptions = {
        host: host,
        port: +(location.port || host.split(':')[1] || 80),
        method: serverReq.method,
        path: location.pathname + (location.search || '') + (location.hash || ''),
        headers: buildHeaders(modifiers, true, serverReq.headers)
    };
    var clientReq = require('http').request(requestOptions, function(clientRes) {
        serverRes.writeHead(clientRes.statusCode, buildHeaders(modifiers, false, clientRes.headers));
        clientRes.on('data', function(data) {
            serverRes.write(data);
        });
        clientRes.on('end', function() {
            serverRes.end();
        });
    });

    clientReq.on('error', function(err) {
        console.log('Request error: ' + err.message);
        serverRes.end();
    });

    serverReq.on('data', function(data) {
        clientReq.write(data);
    });

    serverReq.on('end', function() {
        clientReq.end();
    });
}


function fileRequest(serverRes, fname, modifiers) {
    require('path').exists(fname, function(exists) {
        if (exists) {
            require('fs').stat(fname, function(err, stat) {
                if (err) {
                    console.log('File stat error: ' + err.message);
                    serverRes.end();
                    return;
                }

                if (stat.isFile()) {
                    var parts = fname.split('.');
                    var mimeType = require('mime').getType(parts[parts.length - 1]);
                    if (mimeType.substr(0, 4) == 'text' || mimeType.indexOf('xml') >= 0 || mimeType.indexOf('json') >= 0 || mimeType.indexOf('javascript') >= 0) {
                        mimeType += '; charset=UTF-8';
                    }
                    serverRes.writeHead(200, buildHeaders(modifiers, false, {
                        'Content-Type': mimeType
                    }));
                    require('fs').readFile(fname, function(err, content) {
                        if (err) {
                            console.log('File read error: ' + err.message);
                            serverRes.end();
                            return;
                        }

                        serverRes.write(content);
                        serverRes.end();
                    });

                } else if (stat.isDirectory()) {
                    fileRequest(serverRes, require('path').join(fname, 'index.html'), modifiers);
                } else {
                    serverRes.end();
                }
            })
        } else {
            serverRes.writeHead(404, {
                'Content-Type': 'text/html; charset=UTF-8'
            });
            serverRes.write('Not found');
            serverRes.end();
        }
    });
}


function dataRequest(serverRes, uri, modifiers) {
    var parts = uri.split(';');
    var mimeType = 'text/plain';
    if (parts.length > 1) {
        mimeType = parts.shift();
    }
    var encoding = 'binary';
    if (parts.length > 1 && parts[0].indexOf('charset=') == 0) {
        encoding = parts[0].indexOf('charset=UTF-8') == 0 ? 'utf8' : 'ascii';
        mimeType += '; ' + parts.shift();
    } else if (mimeType.substr(0, 4) == 'text' || mimeType.indexOf('xml') >= 0 || mimeType.indexOf('json') >= 0 || mimeType.indexOf('javascript') >= 0) {
        encoding = 'utf8';
        mimeType += '; charset=UTF-8';
    }
    var data = parts.join(';');
    if (data.indexOf('base64,') == 0) {
        data = base64_decode(data.substr(7));
    } else {
        data = decodeURIComponent(data);
    }
    serverRes.writeHead(200, buildHeaders(modifiers, false, {
        'Content-Type': mimeType
    }));
    serverRes.write(data, encoding);
    serverRes.end();
}


function base64_decode(data) {
    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, enc = '';

    do {  // unpack four hexets into three octets using index points in b64
        h1 = b64.indexOf(data.charAt(i++));
        h2 = b64.indexOf(data.charAt(i++));
        h3 = b64.indexOf(data.charAt(i++));
        h4 = b64.indexOf(data.charAt(i++));

        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

        o1 = bits >> 16 & 0xff;
        o2 = bits >> 8 & 0xff;
        o3 = bits & 0xff;

        if (h3 == 64)     enc += String.fromCharCode(o1);
        else if (h4 == 64) enc += String.fromCharCode(o1, o2);
        else               enc += String.fromCharCode(o1, o2, o3);
    } while (i < data.length);

    return enc;
}

function buildHeaders(modifiers, isRequest, headers) {
    var setModifierName = isRequest ? 'setRequestHeader' : 'setResponseHeader';
    var removeModifierName = isRequest ? 'removeRequestHeader' : 'removeResponseHeader';
    headers = headers || {};
    modifiers.forEach(function(modifier) {
        if (modifier.name == setModifierName) {
            var headerParts = modifier.value.split(':');
            headers[headerParts.shift().trim().toLowerCase()] = headerParts.join(':').trim();
        } else if (modifier.name == removeModifierName) {
            delete headers[modifier.value.trim().toLowerCase()];
        }
    });
    return headers;
}